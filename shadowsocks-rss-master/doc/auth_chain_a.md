# auth_chain_a

### TCP

#### 1. The structure of a handshake request (before encryption)
```
whole request
+--------+--------+
| part 1 | part 2 |
+--------+--------+
|   12   |   24   |
+--------+--------+
part 1
+--------+----------+
| Random | HMAC-MD5 |
+--------+----------+
|    4   |     8    |
+--------+----------+
part 2
+-----+----------------------------+----------+
| UID | AES-128-CBC encrypted data | HMAC-MD5 |
+-----+----------------------------+----------+
|  4  |             16             |     4    |
+-----+----------------------------+----------+
AES-128-CBC encrypted data (before encryption)
+-----+-----+---------------+----------+---------+
| UTC | CID | Connection ID | overhead | reserve |
+-----+---------------------+----------+---------+
|  4  |  4  |       4       |     2    |    2    |
+-----+-----+---------------+----------+---------+
part 1 HMAC is client_hash
part 2 HMAC is server_hash
UID is xor with client_hash from 9th byte to 12nd byte
All length or size or timer are little-endian
The key of AES128 encryption is:
    Base64(user_key) + salt
    salt is "auth_chain_a"
The IV of AES128 encryption is: "\x00" * 16
Connection ID is an unsigned 32bit integer, it must +1 after each handshake request sent
CID is randomly generated by SSR client. And Connection ID need to be initialized with a random integer between 0~0xFFFFFF when generate a new CID
Client must keep the CID value until Connection ID exceed 0xFF000000
overhead is protocol overhead size + obfs overhead size  (<=== overhead.length =4 or =2????? --Akkariiin)

The user_key is user definition or stream encryption key
```
Notice: The HMAC key in part 1:  
IV + key

The HMAC key in part 2:  
user\_key

The HMAC input in part 1 is the Random byte in part 1

The HMAC input in part 2 is whole data in part 2 except HMAC itself

#### 2. The structure of any other packet
```
+------+--------------+---------+--------------+----------+
| size | Random bytes | Payload | Random bytes | HMAC-MD5 |
+------+--------------+---------+--------------+----------+
|  2   |   Variable   |   size  |   Variable   |     2    |
+------+--------------+---------+--------------+----------+

The "size" is the Payload size, little-endian
```
size is xor with client\_hash or server\_hash last 2 bytes  
Random bytes length is genarated by xorshift128plus which init with client\_hash & size if send to server or with server\_hash & size if send to client

Payload encrypted by RC4 method with key Base64(user\_key)+Base64(client\_hash)  *(<===client\_hash????? --Akkariiin)*

The HMAC key is user\_key + Chunk ID. Chunk ID is a 32bit unsigned integer counted from 1 and must be converted to little-endian. The HMAC result become new client\_hash or server_hash for next chunk.

Notice:  
first 2 bytes of the Payload of the first packet which server sent is TCP_MSS 

### UDP
1.Client to server
```
+---------+--------------+--------+-----+----------+
| Payload | Random bytes | Random | UID | HMAC-MD5 |
+---------+--------------+--------+-----+----------+
|Variable |   Variable   |    3   |  4  |     1    |
+---------+--------------+--------+-----+----------+
```
let mac\_code is HMAC(Random, stream\_encryption\_key)  
UID is xor with mac\_code from 1st byte to 4th byte  
Random bytes length is genarated by xorshift128plus which init with mac_code  
Payload encrypted by RC4 method with key Base64(user\_key)+Base64(mac\_code)  
The final HMAC key is user\_key

2.Server to client
```
+---------+--------------+--------+----------+
| Payload | Random bytes | Random | HMAC-MD5 |
+---------+--------------+--------+----------+
|Variable |   Variable   |    7   |     1    |
+---------+--------------+--------+----------+
```
let mac\_code is HMAC(Random, stream\_encryption\_key)  
Random bytes length is genarated by xorshift128plus which init with mac_code  
Payload encrypted by RC4 method with key Base64(user\_key)+Base64(mac\_code)  
The final HMAC key is user\_key

